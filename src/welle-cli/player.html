<script type="text/javascript">

  // @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&dn=gpl-2.0.txt GPL-v2-or-Later
  const nodes = document.querySelectorAll("audio,video");
  const playlists = {};
  const prefetchedTracks = new Map(); // use a map for insertion order, so we can just blow away old entries.
  // maximum prefetched blobs that are kept.
  const MAX_PREFETCH_KEEP = 1;
  // maximum allowed number of entries in a playlist to prevent OOM attacks against the browser with self-referencing playlists
  const MAX_PLAYLIST_LENGTH = 1000;
  const PLAYLIST_MIME_TYPES = ["audio/x-mpegurl", "audio/mpegurl", "application/vnd.apple.mpegurl", "application/mpegurl", "application/x-mpegurl"];

  const SERVER_URL = "10.0.0.1:8000"
  var g_TrackUrl = ""
  var g_TrackName = ""
  var img

  function updateImg() {
    img.src = "";
    img.src = 'http://' + SERVER_URL + '/slide/' + g_TrackUrl.slice(-6) + '?' + (new Date()).getTime();
    img.alt = getName(g_TrackName)
  }

  function stripUrlParameters(link) {
    const url = new URL(link, window.location);
    url.search = "";
    url.hash = "";
    return url.href;
  }
  function isPlaylist(link) {
    const linkHref = stripUrlParameters(link);
    return linkHref.endsWith(".m3u") || linkHref.endsWith(".m3u8");
  }
  function isBlob(link) {
    return new URL(link, window.location).protocol == 'blob';
  }

  function getName(extInfo) {
    let name = new String(extInfo.match(/,(.*)$/g)[0]).substring(1)
    return name
  }

  function parsePlaylist(textContent) {
    let retNames = textContent.match(/EXTINF.*$/mg)
    let retUrl = textContent.match(/^(?!#)(?!\s).*$/mg)
      .filter(s => s)
    let items = []
    for (i = 0; i < retUrl.length; i++) {
      items[i] = { name: retNames[i], url: retUrl[i] }
    }
    console.log(items)
    return items; // filter removes empty strings
  }
  /**
   * Download the given playlist, parse it, and store the tracks in the
   * global playlists object using the url as key.
   *
   * Runs callback once the playlist downloaded successfully.
   */
  function fetchPlaylist(url, onload, onerror) {
    const playlistFetcher = new XMLHttpRequest();
    playlistFetcher.open("GET", url, true);
    playlistFetcher.responseType = "blob"; // to get a mime type
    playlistFetcher.onload = () => {
      if (PLAYLIST_MIME_TYPES.includes(playlistFetcher.response.type)) { // security check to ensure that filters have run
        const reader = new FileReader();
        const load = onload; // propagate to inner scope
        reader.addEventListener("loadend", e => {
          playlists[url] = parsePlaylist(reader.result);
          onload();
        });
        reader.readAsText(playlistFetcher.response);
      } else {
        console.error("playlist must have one of the playlist MIME type '" + PLAYLIST_MIME_TYPES + "' but it had MIME type '" + playlistFetcher.response.type + "'.");
        onerror();
      }
    };
    playlistFetcher.onerror = onerror;
    playlistFetcher.abort = onerror;
    playlistFetcher.send();
  }

  function updateSrc(mediaTag, callback) {

    const playlistUrl = mediaTag.getAttribute("playlist");
    const trackIndex = mediaTag.getAttribute("track-index");
    // deepcopy playlists to avoid shared mutation
    let playlist = [...playlists[playlistUrl]];
    let trackUrl = playlist[trackIndex].url;
    let trackName = playlist[trackIndex].name;
    // swich to the next segment
    mediaTag.setAttribute("src", trackUrl);

    // update title
    mediaTag.parentElement.querySelector(".m3u-player--title").title = getName(trackName);
    mediaTag.parentElement.querySelector(".m3u-player--title").textContent = getName(trackName);
    g_TrackUrl = trackUrl
    g_TrackName = trackName
    updateImg();
    callback();
  }

  function changeTrack(mediaTag, diff) {
    const currentTrackIndex = Number(mediaTag.getAttribute("track-index"));
    const nextTrackIndex = currentTrackIndex + diff;
    const tracks = playlists[mediaTag.getAttribute("playlist")];
    let l_TrackIdx = nextTrackIndex;
    if (nextTrackIndex < 0) {
      l_TrackIdx = tracks.length - 1;
    }
    if (tracks.length <= nextTrackIndex) {
      l_TrackIdx = 0;
    }
    mediaTag.setAttribute("track-index", l_TrackIdx);
    updateSrc(mediaTag, () => mediaTag.play());
  }

  /**
   * Turn a media tag into playlist player.
   */
  function initPlayer(mediaTag) {
    mediaTag.setAttribute("playlist", mediaTag.getAttribute("src"));
    mediaTag.setAttribute("track-index", 0);
    const url = mediaTag.getAttribute("playlist");
    const wrapper = mediaTag.parentElement.insertBefore(document.createElement("div"), mediaTag);
    const controls = document.createElement("div");
    const left = document.createElement("span");
    const title = document.createElement("span");
    const right = document.createElement("span");
    controls.appendChild(left);
    controls.appendChild(title);
    controls.appendChild(right);
    left.classList.add("m3u-player--left");
    right.classList.add("m3u-player--right");
    title.classList.add("m3u-player--title");
    title.style.overflow = "hidden";
    title.style.textOverflow = "ellipsis";
    title.style.whiteSpace = "nowrap";
    title.style.opacity = "0.3";
    title.style.direction = "rtl"; // for truncation on the left
    title.style.paddingLeft = "0.5em";
    title.style.paddingRight = "0.5em";
    title.style.margin = "auto";
    controls.style.display = "flex";
    controls.style.justifyContent = "space-between";
    const styleTag = document.createElement("style");
    styleTag.innerHTML = ".m3u-player--left:hover, .m3u-player--right:hover {color: wheat; background-color: DarkSlateGray}";


    wrapper.appendChild(styleTag);

    img = document.createElement('img');
    img.style.width = "100%"
    wrapper.appendChild(img);
    setInterval(updateImg, 15000);

    wrapper.appendChild(controls);

    // appending the media tag to the wrapper removes it from the outer scope but keeps the event listeners
    wrapper.appendChild(mediaTag);


    left.innerHTML = "&lt;";
    left.style.fontSize = "5em"
    // the tag here and textContent shows the
    // escaped version
    left.onclick = () => changeTrack(mediaTag, -1);
    right.innerHTML = "&gt;";
    right.style.fontSize = "5em"
    right.onclick = () => changeTrack(mediaTag, +1);
    fetchPlaylist(
      url,
      () => {
        updateSrc(mediaTag, () => null);
        mediaTag.addEventListener("ended", event => {
          if (mediaTag.currentTime >= mediaTag.duration) {
            changeTrack(mediaTag, +1);
          }
        });
      },
      () => null);
  }
  function processTag(mediaTag) {
    const canPlayClaim = mediaTag.canPlayType('audio/x-mpegurl');
    let supportsPlaylists = !!canPlayClaim;
    if (canPlayClaim == 'maybe') { // yes, seriously: specced as you only know when you try
      supportsPlaylists = false;
    }
    if (!supportsPlaylists) {
      if (isPlaylist(mediaTag.getAttribute("src"))) {
        initPlayer(mediaTag);
      }
    }
  }
  document.addEventListener('DOMContentLoaded', () => {
    const nodes = document.querySelectorAll("audio,video");
    nodes.forEach(processTag);
  });
  // @license-end

</script>

<html>

<head>
  <title>player</title>
</head>

<body id="body" style="background-color:black; color:white;">
  <div style="width: 80%;margin-left: 10%; margin-right: 10%;">
    <h1>MatMat Radio !</h1>
    <audio style="width: 100%" id="player" src="http://10.0.0.1:8000/play.m3u" preload="none"
      controls="controls">
      not supported?
    </audio>
  </div>

</body>

</html>